from concurrent import futures
import logging
import os
import sys
from pathlib import Path
import threading

root_directory = Path(__file__).resolve().parent.parent
sys.path.append(str(root_directory))

import grpc
from grpc_start import lock_pb2_grpc
from grpc_start import lock_pb2

# The server is required to have the following functionality:
# 1.  Create 100 files that clients can write. The file name should strictly follow this format "file_0", "file_1", ..., "file_99".
# 2.  Maintain one lock object, we use one lock to protect all the files for the sake of simplicity. In real world, there can be one lock per file.
# 3.  Receiving packets from a client and spawning a new thread to handle it. This will allow for multiple clients to connect at the same time. To note that, servers
# generated by  rpcgen  do not have multi-threading, you have to implement it.

DEBUG = True

class LockServer(lock_pb2_grpc.LockServiceServicer):

    # track connected clients in a Set
    def __init__(self):
        self.lock = threading.Lock()
        self.lock_owner = None
        self.clients = {}
        self.seq = 1

    def client_init(self, request, context): 
        client_id = context.peer()
        self.clients[self.seq] = client_id
        self.seq += 1
        if DEBUG:
            print("client_init received: " + str(request.rc))
            print("connected clients: " + str(self.clients))
        return lock_pb2.Int(rc=self.seq-1)
    
    def lock_acquire(self, request, context):
        print("lock_acquire received: " + str(request.client_id))
        return lock_pb2.Response(status=lock_pb2.Status.SUCCESS)
    
    def lock_release(self, request, context):
        print("lock_release received: " + str(request.client_id))
        return lock_pb2.Response(status=lock_pb2.Status.SUCCESS)
    
    def file_append(self, request, context):
        print("file_append received: " + str(request.filename))
        return lock_pb2.Response(status=lock_pb2.Status.SUCCESS)
    
    def client_close(self, request, context):
        # get process id and remove from set
        client_id = context.peer()
        self.clients.remove(client_id)
        if DEBUG:
            print("client_close received: " + str(request.rc))
            print("connected clients: " + str(self.clients))
        return lock_pb2.Int(rc=0)
    
def create_files(n = 100):
    # create directory if necessary:
    if not os.path.exists("./files"):
        os.makedirs("./files")
    for i in range(n):
        with open("./files/file_" + str(i), "w") as f:
            f.write("")

def serve():
    port = "50051"
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    lock_pb2_grpc.add_LockServiceServicer_to_server(LockServer(), server)
    server.add_insecure_port("[::]:" + port)
    server.start()
    print("Server started, listening on " + port)
    server.wait_for_termination()

if __name__ == "__main__":

    create_files()
    logging.basicConfig()
    serve()
